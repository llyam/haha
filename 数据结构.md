## 数据结构

`1`（1）顺序表和连那表

`2`（2）栈和队列

`1`（3）树与二叉树

`3`（4）图的储存和遍历

`2`（5）排序和查找

`3`（6）平衡二叉查找树

`2`（7）堆与优先队列

`3`（8）森林和并查集

`4`（9）图论算法入门

`1`（10）字符串匹配算法



### 顺序表与链表

数据结构介绍 ：

!数据结构 = 结构定义+ 结构操作

#### 顺序表

1、size = 9

2、length = 5

3、data_type = ...

插入：

插入一位 length 变为 6，其他不变

删除：

删除一位 length 又变为 5 ，其他不变

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 //默认申请10
#define DEFAULT_ARG(a, b) ((#a)[0] ? a + 0 : b)
// '+ 0'
#define init(a) __init(DEFAULT_ARG(a, 10))

typedef struct Vector {
    int *data;
    int size, length;
} Vector;

Vector *__init(int n) { //申请空间
    Vector *p = (Vector *)malloc(sizeof(Vector));
    p->data = (int *)malloc(sizeof(int)* n);
    p->size = n;
    p->length = 0;
    return p;
}

int expand(Vector *v) { //扩充空间
    int *p = (int *)realloc(v->data, sizeof(int) * 2 * v->size); //内存泄漏
    if (p == NULL) return 0;
    v->data = p;
    v->size *= 2;
    printf("[%p]expand Vector success, the new size : %d\n",v->data ,v->size);
    return 1;
}

int insert(Vector *v, int value, int ind) { //数据输入
    if (v->length == v->size) {
        if (expand(v) == 0) {
            return 0;
        }
    }
    if (v->length == v->size) return 0;
    if (ind < 0 || ind > v->length) return 0;
    for (int i = v-> length - 1; i >= ind; --i) {
        v->data[i + 1] = v->data[i];
    }
    v->data[ind] = value;
    v->length += 1;
    return 1;
} 

int erase(Vector *v, int ind) {  //删除数据
    if (v->length == 0) return 0;
    if (ind < 0 || ind >= v -> length) return 0;
    for (int i = ind + 1; i < v->length; i++) {
        v->data[i - 1] = v->data[i];
    }
    v->length -= 1;
    return 1;
}

int clear(Vector *v) { //清空
    if (v == NULL) {
        return 0;
    }
    free(v -> data);
    free(v);
    return 1;
}

int output(Vector *v) { //输出
    printf("Vector = [");
    for (int i = 0; i < v->length; i++) {
        printf(" %d", v->data[i]);
    }
    printf(" ]\n");
}

int main() {
    Vector *v = init(); //申请空间
    #define max 20
    for (int t = 0; t < max; t++) {
        int op = rand() % 4, ind, value;
        switch (op) {
            case 2: 
            case 3:
            case 0: {
                ind = rand() % (v->length + 3) - 1;    
                value = rand() % 100;    
                printf("insert(%d, %d) to vector %d\n", value, ind, insert(v, value, ind));
                output(v);
            } break;
            case 1: {
                ind = rand() % (v->length + 3) - 1;
                printf("erase(%d) = %d from vector\n", ind, erase(v, ind));
                output(v);
            } break;
        }
    }
    clear(v);
    return 0;
}
```



#### 链表

程序内部

插入：

单向链表插入 ：把head看作整个单向循环链表的尾结点 ，当尾部改变时head改变

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode;

typedef struct Linklist {
    LinkNode head;
    int length;
} Linklist;

Linklist *init() {
    Linklist *p = (Linklist *) malloc (sizeof(Linklist));
    p->head.next = NULL;
    p->length = 0;
    return p;
}

LinkNode *getNewNode(int value) {  //输入数据
    LinkNode *p = (LinkNode *)malloc(sizeof(LinkNode));
    p -> data = value;
    p -> next = NULL;
    return p;
}

void insert(Linklist *l, int value, int ind) {
    LinkNode *p = &(l->head); //虚拟头
    while (ind--) {    //遍历
        p = p -> next;
        if (p == NULL)  return ;
    }
    LinkNode *new_node = getNewNode(value); //申请空间并输入数据
    new_node->next = p -> next;
    p -> next = new_node;
    l->length += 1;
    return ;
}

void erase(Linklist *l, int ind) {
    LinkNode *p = &(l->head);
    while(ind--) {
        p = p->next;
        if (p == NULL) return ;
    }
    if (p -> next == NULL) return ;
    LinkNode *q = p -> next;
    p -> next = p -> next -> next;
    free(q);
    l->length -= 1;
    return ;
}

void clear(Linklist *l) {
    if (l->head.next == NULL) return ;
    LinkNode *p = l->head.next, *q;
    while (p) {
        q = p;
        p = p -> next;
        free(q);
    }
    free(l);
    return;
}

void output(Linklist *l) {
    printf("[%d]\n", l->length);
    LinkNode *p= l->head.next;
    while (p) {
        printf("%d->", p->data);
        p = p -> next;
    }
    printf("NULL\n");
    return;
}
int main() {
    srand(time(0));
    Linklist *l = init();
    #define max 20
    for (int i = 0; i < max; i++) {
        int op = rand() % 4, value, ind;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                ind = rand() % (l->length + 1);
                value = rand() % 100;
                printf("insert(%d, %d), to Linklist\n", value, ind);
                insert(l, value, ind);
                output(l);
            } break;
            case 3: {
                if (l->length == 0) break;
                ind = rand() % l->length;
                printf("erase (%d) from Linklist\n", ind);
                erase(l, ind);
                output(l);
            } break;
        }
    }
    clear(l);
    return 0;
}
```



### 栈和对列

#### 队列

1.length  2.head  3.tail  4.data 

假溢出          循环队列

先进后出

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ll long long
typedef struct Queue{
    int *data;
    int head, tail, length, cnt;
}Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->length = n;
    q->cnt = 0;		
    q->head = 0;    //头
    q->tail = -1;	//尾
    q->data = (int *)malloc(sizeof(int) * n);
    return q;
}

int push (Queue *q, int value) {
    if (q->cnt == q->length) return 0;
    q->tail += 1;
    if (q->tail >= q->length) q->head -= q->length;
    q->cnt += 1;
    q->data[q->tail] = value;
    return 1;
}

int empty (Queue *q) {
    return q->head > q->tail;
}

void pop(Queue *q) {
    if (empty(q)) return ;
    q->head += 1;
    if (q->head >= q->length) q->head -= q->length;
    q->cnt -= 1;
    return ;
}

int front(Queue *q) {
    if (empty(q)) return 0;
    return q->data[q->head];
}

void output(Queue *q) {
    printf("q = [");
    for (int i = 0; i < q->cnt; i++) {
        int ind = (q->head + i) % q->length;
        printf(" %d", q->data[ind]);
        i + 1 == q->cnt || printf(",");
    }
    printf(" ]\n");
    return ;
}

void clear(Queue *q) {
    if(q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    #define max_op 20
    srand(time(0));
    Queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int op = rand() % 4, value = rand() % 100;
        switch (op){
            case 0:
            case 1:
            case 2: 
                push(q, value);
                printf("push %d to Queue\n", value);
                output(q);
                break;
            case 3: 
                printf("pop %d from Queue\n", front(q));
                pop(q);
                output(q);
                break;
        }
    }
    clear(q);
    return 0;
}
```



#### 栈

size  top data

本质：

包含关系问题

先进先出

```c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Stack {
    int *data;
    int top, size;
}Stack;

Stack *init (int n) {
    Stack *s = (Stack *) malloc (sizeof(Stack));
    s->data = (int *)malloc(sizeof(int) * n);
    s->size = n;
    s->top = -1;
    return s;
}

int empty(Stack *s) {
    return s->top == -1;
}

int top(Stack *s) {
    if(empty(s)) return 0;
    return s->data[s->top];
}

int push(Stack *s, int value) {
    if (s->top + 1== s->size) return 0;
    s->top += 1;
    s->data[s->top] = value;
    return 1;
}

void pop(Stack *s) {
    if (empty(s)) return ;
    s->top -= 1;
}

void clear (Stack *s) {
    if (s == NULL) return ;
    free( s->data );
    free(s);
    return ;
}

void output(Stack *s) {
    printf("Stack = [");
    for (int i = s->top; i >= 0; i--) {
        printf(" %d", s->data[i]);
        i && printf(",");
    }
    printf(" ]\n");
}
int main() {
    srand(time(0));
    #define max_op 20
    Stack *s = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int op = rand() % 4, value = rand() % 100;
        switch(op) {
            case 1:
            case 0:
            case 2: 
            push(s, value);
            printf("push %d to Stack\n", value);
            output(s);
            break;
            case 3: 
            printf("pop %d from Stack\n", top(s));
            pop(s);
            output(s);
            break;
        }
    }
    clear(s);
    return 0;
}
```





### 树

!  树的结点叫集合  边叫关系

```c
struct struct Node 
	int data;
	struct Node *next[3]; 
} Node , *Tree;
```

链表是特殊的树



完全二叉树：没有右侧右结点      

编号为i的结点        左侧：2 * n

​				右侧 ：2 * n +1 = 右侧结点

满二叉树：

！记录式改计算式 算法优化手段

计算式提升空间利用率 

广义表 ：

空树 （）

A / A（）           

A（B,) / A(B, )      

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
        
}  Node;


Node *init(int data) {
    Node *p = (Node *) malloc(sizeof (Node));
    p->data = data;
    p->lchild = p->rchild = NULL;
    return p;
}

void clear (Node *root) {
    if (root == NULL) return ;
    clear(root -> lchild);
    clear(root -> rchild);
    free(root);
    return ;
}


Node *build() {
    Node *root = init(1);
    root -> lchild = init(2);
    root -> rchild = init (3);
    root -> lchild->lchild  = init(6);
    root -> rchild -> rchild = init(7);
    root -> lchild -> lchild -> lchild = init(12);
    root -> rchild -> lchild = init(5);
    root -> rchild -> rchild = init(9);
    root -> rchild -> lchild -> lchild = init(10);
    root -> rchild -> lchild -> rchild = init(11);
    return root;
}

int height_tree (Node *root) {
    if ( root == NULL) return 0;
    int lh = height_tree (root -> lchild), rh = height_tree(root->rchild);
    return (lh > rh ? lh : rh) + 1;
}

void preorder(Node *root) {
    if (root == NULL) return ;
    printf("tree = %d\n", root -> data);
    preorder(root->lchild);
    preorder(root->rchild);
    return ;
}

void inorder (Node *root) {
    if(root == NULL) return ;
    inorder (root -> lchild);
    printf("tree = %d\n", root ->data);
    inorder (root -> rchild);
    return ;
}



int main() {
    Node *root = build ();
    printf("height tree = %d\n ", height_tree(root));
    preorder(root);
    inorder(root);
    //preorder(root);
    clear(root);
}
```



### 堆和优先队列

完全二叉树可以存储在连续的数组当中

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int key;
    struct Node *lchild, *rchild; 
}Node;

typedef struct Stack {
    Node **data;
    int top, size;
}Stack;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NULL;
    return p;
}

Stack *initStack(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (Node **)malloc(sizeof(Node *) * n);
    s->size = n;
    s->top = -1;
    return s;
}

int empty(Stack *s){
    return s == NULL || s->top == -1; 
}

void pop(Stack *s) {
    if (empty(s)) return ;
    s->top -= 1;
    return ;
}

void push(Stack *s, Node *root) {
    if (s->top + 1 == s->size) return ;
    s->data[++(s->top)] = root;
    return ;
}

Node *top(Stack *s){
    if (s == NULL) return 0;
    return s->data[s->top];
}

void clearstack(Stack *s) {
    if (s == NULL) return;
    free(s->data);
    free(s);
    return;
}
void cleartree(Node *root) {
    if (root == NULL) return ;
    cleartree(root->lchild);
    cleartree(root->rchild);
    free(root);
    return ;
}

Node *build(const char *str, Stack *s) {
    Node *p = NULL, *root = NULL;
    //Stack *s = initStack(100);
    int k = 0;
    while (str[0]) {
        switch(str[0]) {
            case '(' : {
                push(s, p);
                k = 0;
            }break;
            case ')' : {
                pop(s);
            } break;
            case ',' : {
                k = 1;
            } break;
            case ' ' : break;
            default :{
                p = getNewNode(str[0]);
                if (root == NULL) root = p;
                if (empty(s)) break;
                if (k == 0) top(s)->lchild = p;
                else top(s)->rchild = p;
            } break;
        }
        str++;
    }
    return root;
} 

void output(Node *root) {
    if (root == NULL) return ;
    printf("%c ", root->key);
    output(root->lchild);
    output(root->rchild);
    return ;
}

void outputstack(Stack *s) {
    if (s == NULL) return ;
    for (int i = 0; i < s->top; i++) {
        if (s->data[i]->lchild != NULL) {
            printf("%c", s->data[i]->lchild);
        }
        if (s->data[i]->rchild != NULL) {
            printf("%c", s->data[i]->rchild);
        }
    }
}

int main() {
    char str[100];
    Node *root = NULL;
    while (scanf("%[^\n]s", str) != EOF) {
        Stack *s = initStack(100);
        getchar();
        output(root = build(str, s));
        outputstack(s);
        clearstack(s);
        cleartree(root);
    }
    return 0;
}
```



#### 堆排序

堆和队列的区别：

优先级大小来进行出堆

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b, b = __temp; \
}

typedef struct priority_queue {
    int *data;
    int size, cnt;
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q  = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->cnt = 0;
    q->size = n + 1;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int push(priority_queue *q, int value) {
    if (q->cnt == q->size) return 0;
    q->data[++(q->cnt)] = value;
    int ind = q->cnt;
    while(ind > 1) {
        if (q->data[ind] <= q->data[ind >> 1]) break;
        swap(q->data[ind],q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}


int pop(priority_queue *q) {
    if (empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        int temp = ind;
        if (q->data[temp] < q->data[ind << 1]) temp = ind << 1;
        if ((ind << 1 | 1) <= q->cnt && q->data[temp] < q->data[ind << 1 | 1]) temp = ind << 1 | 1;
        if (temp == ind) break;
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

int top(priority_queue *q) {
    if (empty(q)) return 0;
    return q->data[1];
}

void output(priority_queue *q) {
    printf("queue = [");
    for (int i = 1; i <= q->cnt; i++) {
        printf(" %d", q->data[i]);
        i == q->cnt || printf(",");
    }
    printf("]\n");
    return ;
}

void clear(priority_queue *q) {
    if (q == NULL ) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    #define max 20
    srand(time(0));
    priority_queue *q = init(max);
    for (int i = 0; i < max; i++) {
        int op = rand() % 4, value = rand() % 100;
        switch (op) {
            case 0:
            case 1:
            case 2: 
                printf("push %d to priority_queue\n", value);
                push(q, value);
                break;
            case 3:
                printf("pop %d in priority_queue\n", top(q));
                pop(q);
                break;
        }
        output(q);
    }
    return 0;
}
```

