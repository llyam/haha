## 并查集

解决连通性问题

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct DisjointSet{
    //声明一个数组　　存储他的父亲节点
    int *father;
} DisjointSet;

void init(DisjointSet *s, int size) {
    //申请空间
    s->father = (int *)malloc(sizeof(int) * size);
    for (int i = 0; i < size; ++i) {
        s->father[i] = i;//将其全部初始化为自己
    }
}

void swap(int *a, int *b) {　//交换
    int temp = *a;
    *a = *b;
    *b = temp;
}

int max(int a, int b) { //找最大值
    return a > b ? a : b;
}

int find_set(DisjointSet *s, int node) {//返回他的根节点
    if (s->father[node] != node) {
        return find_set(s, s->father[node]);
    }
    return node;
}

int merge(DisjointSet *s, int node1, int node2) {//合并操作
    int ancestor1 = find_set(s, node1);　//node1的根节点
    int ancestor2 = find_set(s, node2); //node2的根节点
    if (ancestor1 != ancestor2) {　//如果两个人老大不同就合并操作
        s->father[ancestor1] = ancestor2;
    	return 1;//成功返回１
    }
    return 0;//两个人本身就在同一个集合
}

void clear(DisjointSet *s) {//清除操作
    free(s->father);
    free(s);
}

int main() {
    DisjointSet *dsu = (DisjointSet *)malloc(sizeof(DisjointSet));
    //申请空间
    init(dsu, 100);
    int m, x, y;
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        scanf("%d%d", &x, &y);
        int ans = merge(dsu, x, y);
        if (ans) {
            printf("success\n");
        } else {
            printf("failed\n");
        }
    }
    
    clear(dsu);
    return 0;
}
```



### １、按秩合并

在一种极端情况下如Ｎ个元素退化为一条链，而查找时就会遍历整条连时间复杂度为O(n)

为了避免这种情况，我们可以再合并的时候尽可能的让树的深度不要过深

我们就需要申请一个新的数组存储深度ｒａｎｋ

将ｒａｎｋ数组全部初始化为１

```c
int merge(DisjointSet *s, int node1, int node2) {
    int ancestor1 = find_set(s, node1);//查找node1的根节点
    int ancestor2 = find_set(s, node2);//查找node2的根节点
    if (ancestor1 != ancestor2) {　//两个不属于一个集合合并
    	if (s->rank[ancestor1] > s->rank[ancestor2]) {
        	swap(&ancestor1, &ancestor2);
    	}
        //将深度大的定义为ａｃｅｓｔｏｒ２
        s->father[ancestor1] = ancestor2;//将ａｎｃｅｓｔｏｒ２设置为ａｎｃｅｓｔｏｒ１的父亲节点
        s->rank[ancestor2] = max(s->rank[ancestor2], s->rank[ancestor1] + 1);
        //合并后深度变为原来的深度加上一个根或者原来ｒａｎｋ２深度而这种大的
        return 1;
    }
    return 0;
}
```



### ２、路径压缩

原来的只是将根节点返回，我们可以将自身节点直接连接到其根节点当中

```c
int find_set(DisjointSet *s, int node) {
    if (s->father[node] != node) {
    	s->father[node] = find_set(s, s->father[node]);//将找到的根节点返回
    }
    return s->father[node];
}
```

### ３、习题

* #### 杭电ｏｊ

1232   4496

```c

//p1232
#include<stdio.h>
#include <stdlib.h>

int find(int *node, int value) {
    if (node[value] != value) {
        node[value] = find(node, node[value]);
    }
    return node[value];
}

void bing(int *node, int x, int y) {
    int a1 = find(node, x);
    int a2 = find(node, y);
    if (a1 != a2) {
        node[a1] = a2;
    }
}

int main() {
    int m, n;
    while (scanf("%d", &m) && m != 0) {
        scanf("%d", &n);
        int x, y, num = 0;
        int *node = (int *)malloc(sizeof(int) * m + 1);
        for (int i = 0; i < m; i++) {
            node[i] = i;
        }
        for (int i = 0; i < n; i++) { 
            scanf("%d %d", &x, &y);
            bing(node, x - 1, y - 1);
            num++;
        }
        int nx[1001] = {0}, max = 0;
        for (int i = 0; i < m; i++) {
            if (nx[find(node, i)] == 0) {
                nx[find(node, i)] = 1;
                max++;
            }
        }
        printf("%d\n", max - 1);
        free(node);
    }
    return 0;
}
```

```c
//4496
#include<stdio.h>
#include <stdlib.h>

int find(int *node, int value) {
    if (node[value] != value) {
        node[value] = find(node, node[value]);
    }
    return node[value];
}

int bing(int *node, int x, int y) {
    int a1 = find(node, x);
    int a2 = find(node, y);
    if (a1 != a2) {
        node[a1] = a2;
        return 1;
    }
    return 0;
}

int main() {
    int m, n;
    while (scanf("%d", &m) != EOF) {
        scanf("%d", &n);
        int x[100001], y[100001], num[100001];
        int *node = (int *)malloc(sizeof(int) * (m + 1));
        for (int i = 0; i < m; i++) {
            node[i] = i;
        }
        for (int i = 0; i < n; i++) { 
            scanf("%d %d", &x[i], &y[i]);
        }
        int max = m;
        for (int i = n - 1; i >= 0; i--) {
            num[i] = max;
            max -= bing(node, x[i], y[i]);
        }
        int nx[100001] = {0};
        for (int i = 0; i < n; i++) {
            printf("%d\n", num[i]);
        }
        free(node);
    }
    return 0;
}
```



* #### 计蒜客习题前两道（没做完）

游戏分组　

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct Node {
    int *father, *rank;
}Node;

void init(Node *s, int size) {
    s->father = (int *) malloc (sizeof(int) * size);
    s->rank = (int *) malloc (sizeof(int) * size);
    for (int i = 0; i < size; i++) {
        s->father[i] = i;
        s->rank[i] = 1;
    }
    return ;
}
int max(int a, int b) {
    return a > b ? a : b;
}
void swap(int *x, int *y) {
    int tem = *x;
    *x = *y;
    *y = tem;
}
int find(Node *s, int node) {
    if (s->father[node] != node) {
        s->father[node] = find(s, s->father[node]);
    }
    return s->father[node];
}

void myset(Node *s, int x, int y) {
    int a1 = find(s, x);
    int a2 = find(s, y);
    if (a1 != a2) {
        if (s->rank[a1] > s->rank[a2]) {
            swap(&a1, &a2);
        }
        s->father[a1] = a2;
    	s->rank[a2] = max(s->rank[a1], s->rank[a2] + 1);
    }
} 
void clear(Node *s) {
    free(s->father);
    free(s->rank);
    free(s);
}
int main() {
    int m, n, x, y, sum = 0;
    Node *s = (Node *) malloc (sizeof(Node));
    scanf("%d %d", &m, &n);
    int num[1000000] = {0};
	init(s, m);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &x, &y);
    	myset(s, x, y);
    }
    for (int i = 0; i < m; i++) {
        num[s->father[i]] = 1;
    }
    for (int i = 0; i < m; i++) {
        if (num[i] != 0) sum++;
    }
    printf("%d\n", sum);
    clear(s);
}
```

冗余关系

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct Node {
    int *father;
    int *rank;
}Node;
int max(int x, int y) {
    return x > y ? x : y;
}
void init(Node *s, int x) {
    s->father = (int *)malloc(sizeof(int) * x);
    s->rank = (int *)malloc(sizeof(int) * x);
    for (int i = 0; i < x; i++) {
        s->father[i] = i + 1;
        s->rank[i] = 1;
    }
    return ;
}
int find(Node *s, int node) {
    //printf("%d ", node);
    if (s->father[node - 1] != node) {
        s->father[node - 1] = find(s, s->father[node - 1]);
    }
    return s->father[node - 1];
}
int bing(Node *s, int x, int y) {
    int a1 = find(s, x);
    int a2 = find(s, y);
   // printf("a1=%d, a2=%d\n", a1, a2);
    if(a1 != a2) {
        if (s->rank[a1 - 1] > s->rank[a2 - 1]) {
            int temp = a1;
            a1 = a2;
            a2 = temp;
        }
        s->father[a1 - 1] = a2;
        s->rank[a2 - 1] = max(s->rank[a2 - 1], s->rank[a1 - 1] + 1);
        return 1;
    }
    return 0;
}
void clear(Node *s) {
    free(s->father);
    free(s->rank);
    free(s);
}
int main() {
    int m, n, x, y, sum = 0;
    scanf("%d %d", &m, &n);
    Node *s = (Node *)malloc(sizeof(Node));
    //printf("init\n");
    init(s, 1001);
    //printf("for\n");
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &x, &y);
    	if (bing(s, x, y) == 0) sum++;
    }
    printf("%d\n", sum);
	clear(s);
    return 0;
}
```



* #### 洛谷

p1111 修复公路

```c
#include <stdio.h>
#include <stdlib.h>
int max(int x, int y) {
    return x > y ? x : y;
}
typedef struct Node {
    int x, y, z;
} Node;

int find(int *father, int node) {
    if (father[node] != node) {
        return find(father, father[node]);
    }
    return father[node];

}

void sort(Node *num, int l, int r) {
    if (r <= l) return ;
    int x = l, y = r;
    Node mi = num[l];
    while (x < y) {
        while (x < y && num[y].z >= mi.z) --y;
        if (x < y) num[x++] = num[y];
        while (x < y && num[x].z <= mi.z) ++x;
        if (x < y) num[y--] = num[x];
    }
    num[x] = mi;
    sort(num, l, x - 1);
    sort(num, x + 1, r);
    return ;
}

int main() {
    int m, n;
    scanf("%d %d", &m, &n);
    Node *p = (Node *) malloc (sizeof(Node) * 100001);
    for (int i = 0; i < n; i++) {
        scanf("%d %d %d", &p[i].x, &p[i].y, &p[i].z);
    }
    int num = 0, hh = 0;
    sort(p, 0, n);
    int father[100001];
    for (int i = 0; i <= m+5; i++) {
        father[i] = i;
    }
    for (int i = 0; i < n; i++) {
        int a1 = find(father, p[i].x);
        int a2 = find(father, p[i].y);
        if (a1 != a2) {
            father[a1] = a2;
            num++;
            hh = max(hh, p[i].z);
        }
    }
    if (num < m - 1) {
        printf("-1\n");
    } else {
        printf("%d\n", hh);
    }
        free(p);
}
```

